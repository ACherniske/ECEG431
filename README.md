[![Course](https://img.shields.io/badge/Course-nand2tetris-critical)](https://www.nand2tetris.org/)
![Progress](https://img.shields.io/static/v1?label=Completion&message=83.33%&color=orange)
[![Last Commit](https://img.shields.io/github/last-commit/ACherniske/ECEG431)](https://github.com/ACherniske/ECEG431)
[![github-lang-cout](https://img.shields.io/github/languages/count/ACherniske/ECEG431?style=social&logo=github)](https://github.com/ACherniske/ECEG431)
[![github-top-lang](https://img.shields.io/github/languages/top/ACherniske/ECEG431?style=social&logo=github)](https://github.com/ACherniske/ECEG431)

# ECEG 431 | Computer Systems Engineering

> **Building a Computer from First Principles**

## Course Overview

This comprehensive course explores the fundamental concepts, technologies, and skills essential for advanced computer engineering studies. Students gain deep insights into computer organization, architecture, operating systems, networking, and performance evaluation while understanding their interconnected relationships.

## Learning Approach

This course follows the acclaimed **Nand2Tetris** methodology, providing a complete journey from basic logic gates to a fully functional computer system. Students build every component from scratch, creating a unified understanding of how software and hardware work together.

**What makes this unique:**
- **Bottom-up approach**: Start with NAND gates, end with a complete operating system
- **Hands-on learning**: Build every component yourself
- **Integrated curriculum**: See how all computer systems concepts connect
- **Real-world applications**: Create actual working systems, not just theoretical models

---

## Part I: Hardware Foundation
*Projects 1-6: Building the Physical Computer*

### Project 1: Boolean Logic
**Foundation of Digital Computing**
- Implement fundamental logic gates (AND, OR, NOT, XOR, MUX, DMUX)
- Master the principle: everything builds from NAND gates
- Learn how Boolean algebra translates to hardware

### Project 2: Boolean Arithmetic  
**The Mathematics Engine**
- Design half-adders, full-adders, and multi-bit adders
- Construct the Arithmetic Logic Unit (ALU)
- Understand how computers perform mathematical operations

### Project 3: Sequential Logic
**Adding Memory to the System**
- Build data flip-flops (DFFs) and registers
- Create RAM units of various sizes
- Implement the program counter for instruction sequencing

### Project 4: Machine Language Programming
**Speaking the Computer's Language**
- Master the Hack assembly language
- Write programs that manipulate memory and perform I/O
- Understand the relationship between high-level concepts and machine code

### Project 5: Computer Architecture
**Bringing It All Together**
- Integrate ALU, memory, and control logic into a complete CPU
- Build the Hack computer platform
- Understand the fetch-decode-execute cycle

### Project 6: Assembler Development
**Bridging Human and Machine**
- Create a two-pass assembler
- Translate symbolic assembly code to binary machine language
- Learn about symbol tables and memory allocation

**Learning Points**
- BASH Scripting
- VIM Editor
- C++ Filestructure and Best Practices
- Fileparsing

---

## Part II: Software Stack
*Projects 7-12: Building the Software Ecosystem*

### Project 7: Virtual Machine I - Stack Operations
**Creating an Abstraction Layer**
- Implement a VM translator for stack arithmetic
- Handle memory segment operations
- Bridge the gap between high-level languages and assembly

**Learning Points**
- BASH Scripting
- VIM Editor
- C++ Filestructure and Best Practices
- Fileparsing

### Project 8: Virtual Machine II - Program Flow
**Advanced VM Implementation**
- Add support for branching and function calls
- Implement program flow control
- Handle complex program structures

**Learning Points**
- C++ Filestructure and Best Practices
- Bootstrapping
- Directory Scanning

### Project 9: High-Level Language Design
**Object-Oriented Programming**
- Learn the Jack programming language
- Understand object-oriented concepts
- Write sophisticated applications in a high-level language

### Project 10: Compiler Frontend - Syntax Analysis
**Understanding Code Structure**
- Build a tokenizer and parser
- Generate XML parse trees
- Implement syntax analysis for the Jack language

### Project 11: Compiler Backend - Code Generation
**From Source to Execution**
- Complete the Jack compiler
- Generate VM code from parsed syntax trees
- Understand symbol tables and scope management

### Project 12: Operating System Services
**System-Level Programming**
- Implement core OS functionality: Math, Memory, Screen, Keyboard
- Create system libraries and APIs
- Understand how applications interact with hardware

---

## Learning Outcomes

Upon completion, students will have:

- **Built a complete computer system** from NAND gates to operating system
- **Mastered fundamental CS concepts** through practical implementation
- **Gained deep understanding** of hardware-software interaction
- **Developed systems thinking** essential for advanced computer engineering
- **Created a portfolio** demonstrating comprehensive technical skills

## Skills Developed

| **Hardware Skills** | **Software Skills** | **Systems Skills** |
|-------------------|-------------------|------------------|
| Digital Logic Design | Assembly Programming | Computer Architecture |
| Circuit Implementation | Compiler Construction | Operating System Design |
| Memory Systems | Virtual Machine Design | Performance Analysis |
| CPU Architecture | Language Design | System Integration |

---

## Technologies & Tools

- **HDL (Hardware Description Language)** for hardware design
- **Hack Assembly Language** for low-level programming
- **Jack Programming Language** for application development
- **Custom VM Architecture** for intermediate code representation
- **Bash Scripting** for file processing (Projects 6-8)

---

*This course provides the foundation for understanding how modern computer systems work, from the physics of transistors to the abstractions of operating systems and applications.*